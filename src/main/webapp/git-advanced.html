<!DOCTYPE html>

<!--
	Git : The Basics
	Justin Grant(C) 2012
-->

<html lang='en'>
<head>
	<meta charset='utf-8' />
	<title>Git: Advanced Features and Utilities</title>
	<link href='images/favicon.ico' rel='shortcut icon' type='image/x-icon'>
	<link rel="stylesheet" href="css/font.css" />
	<link rel="stylesheet" href="css/default.css" />
	<link rel="stylesheet" href="css/git-advanced.css" />
</head>
<body>
	<div id="title" class="step">
		<h3 class="right">Justin Grant</h3>
		<div class="notes">
		</div>
	</div>

	<div id="rollingback">
		http://superuser.com/questions/35267/how-can-i-roll-back-1-commit
		http://stackoverflow.com/questions/1955985/what-does-the-caret-character-mean-in-git
	</div>
	<div id="InteractiveRebase" class="step">
		<h3></h3>
		
		Interactive Rebase
		-------------------
		git pull --rebase
		Layer my code changes to the end of someone else's changes.  Note that it doesn't change the timestamps.  It changes the ordered sequence, and layers it on the end.
		
		git config branch.autosetuprebase always -> merges should happen very very rarely.
		
		example:
		git rebase -i HEAD~4
		
			<div class="notes">
			<p>Probably best to show how this works in github or treesource
			
			
		</div>
	</div>
	
	<div id="patchMode" class="step" data-x="-1500" data-y="-3000">
		<h3></h3>
		<div class="notes">
			<p>git add -p myTestFile.txt -> runs patch mode. Allows us to
				commit line by line what you are committing. WATCH OUT! This could
				allow you to commit uncompileable code. y=yes, n=no, s will split
				by minute?
		</div>
	</div>
	
	<div id="cloningFromAnotherLocalComputer" class="step" data-x="-3000"
			data-y="3000">
			<h3></h3>
			<div class="notes">
				<p>
			</div>
		</div>

		<div id="creatingBundles" class="step" data-x="-1500" data-y="3000">
			<h3></h3>
			<p>git init --bare cd /my/files/path/ git init git add . git
				commit -m "initial commit" Create a Bundle --------------- git
				bundle create ../filename.bundle master git ls-remote
				filename.bundle - view contents of a file repository so that you can
				see what to check out git ls-remote https://gihub.com/jlgrock/ -
				view the contents of a remote repository so that you can see what to
				check out git ls-remote origin - view the contents of the origin
				address git fetch filename.bundle refs/heads/master - check out the
				master branch from this file FETCH_HEAD - only know about this due
				to response from git (or looking in the .git folder) This is a
				temporary branch (will not show up in branches) git merge FETCH_HEAD
				-> merge the current branch with this temporary branch git branch
				illCheckThisOutLater FETCH_HEAD -> store contents of FETCH_HEAD into
				illCheckThisOutLater branch git merge -no-ff FETCH_HEAD -> will skip
				fast forward to guarantee a (Pull requests are just a special kind
				of branch) --since can also be used if you don't care about a
				specific version
			<div class="notes">
				<p>Especially useful for one time copies to sil or something
					like that.
			</div>
		</div>
		<div id="RemoteCommands" class="step" data-x="-3000" data-y="1500">
			<h3></h3>
			git remote -v #"-v" = verbose. Shows the set of tracked repositories.
			show (possibly on github) how to be show 2 ahead 1 behind git branch
			-a #shows all of the named branches
			<div class="notes">
				<p>http://git-scm.com/book/en/Git-Basics-Tagging
			</div>

			By default, the git push command doesn’t transfer tags to remote
			servers. You will have to explicitly push tags to a shared server
			after you have created them. This process is just like sharing remote
			branches — you can run git push origin [tagname].
		</div>
	<div id="gitkAndgitg" class="step" data-x="0" data-y="3000">
		<h3></h3>
		<div class="notes">
			<p>gitk & #platform independent gui for viewing commits # will
				show bisect operations
		</div>
	</div>
		
	<div id="SquashMerge" class="step">
		<h3></h3>
		
		<div class="notes">
		<p>lookup squash-merge
		and autosquash (new in 1.7)
			
		</div>
	</div>
	
	<div id="EmailDiff" class="step">
		<h3></h3>
		
		<div class="notes">
		<p>email a diff
		
			
		</div>
	</div>
	
	<div id="GitSVN" class="step">
		<h3></h3>
		git-svn clone -s http://example.com/my_subversion_repo local_dir
		git-svn show-ignore > .gitignore
		git checkout (locally, it's a git repo)
		git-svn rebase
		git-svn dcommit
			<div class="notes">
			<p>Now that you know how to use rebase, you can use git svn.  The git svn commands are limited.
		</div>
	</div>
	
	<div id="GitSVN" class="step">
		<h3></h3>
		Merging - Cherry Pick
		----------------------
		"git cherry-pick a5b2ee" -> merge in just one commit (not an entire branch) - this will list this in the change log, but the log will list a sha1, which may never be published.
		"git cherry-pick a5b2ee..fd341b" -> merge in multiple commits (not an entire branch) with the range

			<div class="notes">
			<p>Now that you know how to use rebase, you can use git svn.  The git svn commands are limited.
		</div>
	</div>
	

	<div id="Bisect" class="step">
		<h3></h3>
		Create/Use Orphaned Branches
		----------------------------
		This is really useful for docs/related materials that has no relation to the code in another branch.
		
		git checkout --orphan newbranchname -> create new fresh, no content branch.  Keeps the current content (staged), just in case you want to add them later.
		create some files with some changes checked in.
		to visualize, "gitk all" - note that the new branch has no line to anything, indicating that it is not conneted to the current code.

			<div class="notes">
			<p>
		</div>
	</div>
			
	<div id="Bisect" class="step">
		<h3></h3>
		git bisect start
		git bisect bad
		git bisect good 128dafd75384f42c2544acd28d432c8abef79878
		
		git bisect start #start looking though
		git bisect bad #mark a point where i know it is bad
		git bisect good #mark a point where i know it is now good
		
		git bisect run mvn test #will run mvn test - will run binary search and record the test status - can narrow it to a single commit that caused the problem
				
			<div class="notes">
			<p>
		</div>
	</div>
	
	git whatchanged -p
	
	git rebase -i HEAD~n
	
	<div id="Bisect" class="step">
		<h3></h3>
		Transport: Push efficiencies
		-----------------------------
		normally, more efficient to push differences
		what if you want to push an entire repo + history + branches ->
		
		git tag -> list tags
		git branch -> list branches
		
		git push --mirror git@github.com:matthewmccullough/mirror1.git -> will push everything in the same way, so /remotes/origin/gh-pages will remain as that full path (problem)
		
		git checkout patch-1
		git help remote
		git remote remove origin -> severs remote from the origin to help us reattach it later
		git branch -a
		git branch -r -> show remote branches
		
		if enough branches, this should be run through a script, (something like "git branch -r | sed s/origin/git\ checkout/")
		Also, this can use any URI, so this can be pushed to a file (e.g. on a thumb drive/cd) for transporting
			<div class="notes">
			<p>
		</div>
	</div>
	
	
		<div id="Bisect" class="step">
		<h3></h3>
			Groups of Remotes
		------------------
		git config --global push.default matching
		vs
		git config --global push.default simple
		
		this means that in the current setup, "git push" (no parameters) will walk through every remote (confusing).
		Meaning, if you've checked in to a bunch of branches, it will attempt to push them all (even the ones you aren't on).
		TEST THIS
		This will change.  Make sure to set this to simple (this will be the default within 6 months)
		
		[remote "Dmackenzie"]
		   url = git://github.com/dmackenzie1/ClosureJavascriptFramework.git
		   fetch = +refs/heads/*:refs/remotes/Dmackenzie/*
		
		[remote "Dmackenzie"]
		        remote = remote other
		        url = git://github.com/dmackenzie1/ClosureJavascriptFramework.git
		        fetch = +refs/heads/*:refs/remotes/Dmackenzie/*
			<div class="notes">
			<p>
		</div>
	</div>
	

        <div id="Bisect" class="step">
		<h3></h3>
			Short Urls/Aliases and username expansion
		-----------
		Can add urls to any level global (for companies), local (I know there's a third...)
		[url "git://github.com"] -> sets the url alias.  If there are duplicates, it's first one wins.
		    insteadOf = "ghh://" -> (optional parameter) fetch insteadOf - replaces "git://github.com" becomes "ghh://" as an alias
		    pushInsteadOf = "ghh://" -> (optional parameter) push insteadOf - (same as fetch)
		
		example command would be "git clone ghh://mirro1 test".
		
		git config contains the following:
		[core]
		        repositoryformatversion = 0
		        filemode = true
		        logallrefupdates = true
		[remote "origin"]
		        url = git@github.com:jlgrock/ClosureJavascriptFramework.git
		        fetch = +refs/heads/*:refs/remotes/origin/*
		[branch "master"]
		        remote = origin
		        merge = refs/heads/master
		        remote "Dmackenzie"]
		        url = git://github.com/dmackenzie1/ClosureJavascriptFramework.git
		        fetch = +refs/heads/*:refs/remotes/Dmackenzie/*
		
		What if I add the following:
		"fetch = +refs/heads/mm*:refs/remotes/origin/*" -> narrows new downloads to a specific subset
		can have as many fetch patterns.  also, you can only use "*" wildcard at the end of the line. (Follows refspec - this is why multiple fetches may be necessary).
		
		--single-branch useful for a clone, then change to narrow down.  Also, you could do an init to create a new git repo, add to config, then add remote, then fetch
			<div class="notes">
			<p>
		</div>
	</div>
        
    <div id="AdvancedWorkflows" class="step">
		<h3>"Advanced Workflows"</h3>
		<div class="notes">
			pull and push can be different...
			<p>
	
			One of the amazing things about Git is that because of its distributed nature and super branching system, you can easily implement pretty much any workflow you can think of relatively easily.
		Subversion-Style Workflow
		
		A very common Git workflow, especially from people transitioning from a centralized system, is a centralized workflow. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.
		
		<!-- workflow-a.png -->
		Integration Manager Workflow
		
		Another common Git workflow is where there is an integration manager—a single person who commits to the 'blessed' repository, and then a number of developers who clone from that repository, push to their own independent repositories and ask the integrator to pull in their changes. This is the type of development model you often see with open source or GitHub repositories.
		
		<!-- workflow-b.png -->
		
		Dictator and Lieutenants Workflow
		
		For more massive projects, you can setup your developers similar to the way the Linux kernel is run, where people are in charge of a specific subsystem of the project ('lieutenants') and merge in all changes that have to do with that subsystem. Then another integrator (the 'dictator') can pull changes from only his/her lieutenants and push those to the 'blessed' repository that everyone then clones from again.
		
		<!-- workflow-c.png -->
		
		Again, Git is entirely flexible about this, so you can mix and match and choose the workflow that is right for you.
		</div>
	</div>

	<div id="bundles">
	http://blog.ekynoxe.com/2010/11/17/git-sync-via-usb/
	http://git-scm.com/2010/03/10/bundles.html</div>
	
	<div id="moreResources">
	http://git-scm.com/book/en/Customizing-Git-Git-Hooks
	
		look @
		http://teach.github.com/classnotes/2012-11-02-nfjs-git-workshop1.html
		
	</div>
</body>
</html>

